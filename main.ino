#include <Arduino.h>
#include <U8g2lib.h>

<<<<<<< HEAD
#define check_sec 200 
#define charge_thresh 0.9
#define max_in 1000.f
#define dc_thresh 15
//may be that tru/false swapped
// A0 A2 A4 A6   true/HIGH [0]
=======
#define check_sec 60 //HOW MANY SECONDS BEFORE NEXT cycleBatt()
#define charge_thresh 14
#define max_in 15
#define dc_thresh 5

// A0 A2 A4 A6   PIN true/HIGH [coil is off]
>>>>>>> 516c596aa5a4946a59d12a08f62fe5be8a1f8fb1
// 2  3  4  5
// A1 A3 A5 A7   PIN false/LOW [coil is on]

//Digital 2,3,4,5 for switching, 10-11 for display
//A0-A7 battery 
//TwoWire (maybe sda11, scl12) for oled
//digital 6 for button

//         PIN LOW, COIL ON|PIN HIGH, COIL OFF
uint16_t charge[4][2] = {{0,0},  // A0,A1
                         {0,0},  // A2,A3
                         {0,0},  // A4,A5
                         {0,0}}; // A6,A7
                         
bool state[4] = {false, false, false, false};

uint8_t timesincerefresh = 0;

U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, /* clock=*/ 11, /* data=*/ 10, /* reset=*/ U8X8_PIN_NONE); 

#define doge_width 128
#define doge_height 48
static const unsigned char doge_bits[] U8X8_PROGMEM = { //More like PROGMEME amirite
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0xE0, 0x01, 0x00, 0x00, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 
  0xE0, 0x03, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x60, 0x00, 0xF0, 0x0F, 0x00, 0xC0, 0x07, 0x00, 0x80, 0x99, 
  0x79, 0x66, 0x06, 0x00, 0x00, 0x00, 0x60, 0x00, 0xF0, 0x3F, 0x00, 0xC0, 
  0x07, 0x00, 0x80, 0x99, 0x7D, 0x66, 0x06, 0xC0, 0x67, 0xC6, 0x63, 0x07, 
  0xF0, 0x7F, 0xC0, 0xE3, 0x0F, 0x00, 0x80, 0xDD, 0xCE, 0x76, 0x03, 0xE0, 
  0x67, 0xE6, 0xE7, 0x0F, 0xF0, 0xFF, 0xF1, 0xE3, 0x1F, 0x00, 0x80, 0xFD, 
  0xC6, 0xF6, 0x03, 0x60, 0x60, 0x66, 0xE6, 0x0C, 0xF0, 0xFF, 0x7F, 0x00, 
  0x1E, 0x00, 0x80, 0xF7, 0xC6, 0xDE, 0x03, 0xC0, 0x61, 0x36, 0x60, 0x0C, 
  0xF0, 0xFF, 0x3F, 0x7C, 0x08, 0x00, 0x80, 0x77, 0xC6, 0xDE, 0x01, 0x80, 
  0x63, 0x36, 0x60, 0x0C, 0xF0, 0xFF, 0x3F, 0xFE, 0x00, 0x07, 0x00, 0x77, 
  0x7C, 0xDC, 0x01, 0x00, 0x66, 0x36, 0x66, 0x0C, 0xF0, 0xFF, 0xFF, 0xFF, 
  0x00, 0x0F, 0x00, 0x23, 0x38, 0x8C, 0x00, 0xE0, 0xE7, 0xE7, 0x67, 0x0C, 
  0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0xC3, 0xC7, 0x63, 0x0C, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x1E, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 
  0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xE0, 0xFF, 0xFC, 0xFF, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x7F, 0xF8, 0xF9, 0x03, 0x38, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0xFC, 0xF0, 
  0xE3, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0xF0, 0x0F, 0x7F, 0xE0, 0xF3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x3F, 0xC0, 0xF1, 0x31, 0x00, 0x9F, 
  0xFD, 0xF0, 0xEC, 0x7E, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x03, 0xDE, 0x07, 
  0xF0, 0x01, 0x80, 0x9F, 0xFF, 0xF9, 0xFD, 0x7E, 0x00, 0x00, 0x00, 0x00, 
  0xF8, 0x01, 0xEC, 0x1F, 0xE0, 0x03, 0x80, 0x81, 0x9B, 0x9D, 0xDD, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0x01, 0xF0, 0x3F, 0x80, 0x01, 0x00, 0x87, 
  0x99, 0x8D, 0xCD, 0x18, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x01, 0xE0, 0x3F, 
  0x00, 0xC0, 0x01, 0x8E, 0x99, 0x8D, 0x0D, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0xF8, 0x00, 0xC0, 0x1F, 0x00, 0xC0, 0x01, 0x98, 0x99, 0x8D, 0x0D, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x03, 0x00, 0x80, 0x83, 0x9F, 
  0x99, 0xFD, 0x0D, 0x18, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
  0xE0, 0x9F, 0x03, 0x8F, 0x99, 0xF9, 0x0D, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0x9F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x3F, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
  0xF8, 0x3F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xF0, 0x00, 0x00, 0x00, 0xF8, 0x3F, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0xF8, 0x3F, 0x03, 0x00, 
  0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x01, 0x00, 0x00, 
  0xF0, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFC, 0x01, 0x00, 0x00, 0xF0, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFE, 0x01, 0x00, 0x00, 0xF8, 0x1F, 0x03, 0x00, 
  0x00, 0x3C, 0x76, 0x78, 0x76, 0x3C, 0x3C, 0x3B, 0xFE, 0x01, 0x00, 0x70, 
  0xF8, 0x8F, 0x03, 0x00, 0x00, 0x7E, 0xFE, 0xFC, 0x7E, 0x7E, 0x7E, 0x3F, 
  0xFE, 0x01, 0x00, 0x70, 0xF8, 0x8F, 0x03, 0x00, 0x00, 0x66, 0xCE, 0xCE, 
  0x6E, 0x67, 0x67, 0x37, 0xFE, 0x03, 0x00, 0xF8, 0xFF, 0x9F, 0x03, 0x00, 
  0x00, 0x03, 0xC6, 0xC6, 0x66, 0x63, 0x7B, 0x33, 0xFF, 0x03, 0x00, 0xF8, 
  0xFF, 0x9F, 0x03, 0x00, 0x00, 0x03, 0xC6, 0xC6, 0x06, 0x63, 0x1F, 0x03, 
  0xFF, 0x03, 0x00, 0xE0, 0xFF, 0xCF, 0x03, 0x00, 0x00, 0x63, 0xC6, 0xC6, 
  0x06, 0x73, 0x07, 0x03, 0xFF, 0x07, 0x00, 0x00, 0xFF, 0xC7, 0x01, 0x00, 
  0x00, 0x7E, 0xC6, 0xFE, 0x06, 0x7F, 0x7E, 0x03, 0xFF, 0x0F, 0x00, 0x00, 
  0xF8, 0xE0, 0x00, 0x00, 0x00, 0x3C, 0xC6, 0xFC, 0x06, 0x7E, 0x3C, 0x03, 
  0xFE, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x60, 0x00, 0x00, 0xFE, 0x3F, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0xFE, 0x3F, 0x00, 0x00, 
  0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 
  0xFC, 0xFF, 0x00, 0x00, 0x80, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x1F, 0x00, 0x00, 0xF8, 0xFF, 0x01, 0x00, 0xF0, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x03, 0x00, 
  0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};


void setup(){
    Serial.begin(9600);
    pinMode(LED_BUILTIN, OUTPUT);
    pinMode(6, INPUT_PULLUP);
    for(uint8_t pin = 2; pin <= 5; pin++)
        pinMode(pin, OUTPUT);

    *digitalPinToPCMSK(6) |= bit (digitalPinToPCMSKbit(6));
    PCIFR  |= bit (digitalPinToPCICRbit(6));
    PCICR  |= bit (digitalPinToPCICRbit(6));
    
    //display setup
    u8g2.begin();

    cycleBatt();

    u8g2.setBitmapMode(false /* solid */);
    u8g2.setFont(u8g2_font_5x8_tf);
    u8g2.setFontPosTop();
    u8g2.setFontMode(false);
    u8g2.setFontDirection(0);
    u8g2.setFontRefHeightExtendedText();
    
    //DRAW STARTUP IMAGE
    u8g2.clearBuffer();
    u8g2.drawXBMP(0, 16, 128, 48, doge_bits);
    u8g2.sendBuffer();

    delay(500); //so people can see it
    
    dispVoltages();
}

void loop(){
<<<<<<< HEAD
    //every 10 seconds switch, check/switch, switch and charge update
    //flash # of charged
    if(digitalRead(6) == LOW || millis() - lastCheck >= check_sec*1000UL){
        lastCheck = millis();
        cycleBatt();

=======
    for(int i = 0; i < check_sec; i++){
>>>>>>> 516c596aa5a4946a59d12a08f62fe5be8a1f8fb1
        Serial.println();
        for(int i = 0; i < 4; i++){
            Serial.print(state[i]);
            Serial.print(", ");
        }
        Serial.println();
        for(int i = 0; i < 4; i++){
            Serial.print(charge[i][0]);
            Serial.print("|");
            Serial.print(charge[i][1]);
            Serial.print(", ");
        }
        Serial.println();
<<<<<<< HEAD
    }

    //debug
    if(millis() - lastUpdate >= 5000){
        //dispVoltages();
=======
        dispVoltages();
        delay(1000);
        timesincerefresh++;
>>>>>>> 516c596aa5a4946a59d12a08f62fe5be8a1f8fb1
    }
    
    //every minute switch, check/switch, switch and charge update
    //flash # of charged
    cycleBatt();
    timesincerefresh = 0;
}

ISR(PCINT2_vect){
    cycleBatt();
}

void cycleBatt(){
    noInterrupts();
    updateCharge();

<<<<<<< HEAD
        //update charge array and swap battery if charged
        for(int i = 0; i < 4; i++){
            if(charge[i][0] <= dc_thresh && 
               charge[i][1] <= dc_thresh)//if both disconnected default idx#1
                state[i] = true;
            else if(charge[i][0]/max_in >= charge_thresh && 
                    charge[i][1] <= dc_thresh)//idx#0 charged, swap to unplugged
                state[i] = false;//idx#1
            else if(charge[i][1]/max_in >= charge_thresh && 
                    charge[i][0] <= dc_thresh)//idx#1 charged, swap to unplugged
                state[i] = true;//idx#0
            else if(charge[i][0] >= charge[i][1] && 
                    charge[i][0]/max_in < charge_thresh) //if idx#0 batt highest+not charged
                state[i] = true;//idx#0
            else 
                state[i] = false;//idx#1
        }
=======
    //update charge array and swap battery if charged
    for(int i = 0; i < 4; i++){
        if(charge[i][0] <= dc_thresh && charge[i][1] <= dc_thresh)//if both disconnected turn coil off to save power/wear on coil idx#0
            state[i] = true;
        else if(charge[i][0]/1024.f*max_in >= charge_thresh && charge[i][1] <= dc_thresh)//idx#0 charged, swap to unplugged
            state[i] = false;//idx#1
        else if(charge[i][1]/1024.f*max_in >= charge_thresh && charge[i][0] <= dc_thresh)//idx#1 charged, swap to unplugged
            state[i] = true;//idx#0
        else if(charge[i][0] >= charge[i][1] && charge[i][0]/1024.f*max_in < charge_thresh) //if idx#0 batt highest+not charged
            state[i] = true;//idx#0
        else 
            state[i] = false;//idx#1
>>>>>>> 516c596aa5a4946a59d12a08f62fe5be8a1f8fb1

    }

    updatePowered();
    blinkCharged();
    interrupts();
}

void updateCharge(){
    //flip
    for(int i = 0; i < 4; i++)
        state[i] = !state[i];
    updatePowered();
    
    //updateCharges
    for(uint8_t i = 0; i < 4; i++)
        charge[i][(uint8_t)(state)] = analogRead(i*2+state);
        //reduced to one line
        /*if(!state[i])//check opposites hopefully
            charge[i][0] = analogRead(i*2);
        else
            charge[i][1] = analogRead(i*2+1);*/
    
    //flip
    for(int i = 0; i < 4; i++)
        state[i] = !state[i];
    updatePowered();

    //updateCharges
    for(uint8_t i = 0; i < 4; i++)
        charge[i][(uint8_t)(state)] = analogRead(i*2+state);
}

void updatePowered(){
    for(int i = 0; i < 4; i++)
        digitalWrite(i+2, state[i]);
    delay(100);//allow relays to swap
}

void blinkCharged(){
    //blink number of charged batteries
<<<<<<< HEAD
    uint8_t tot = 0, max = 8;
    for(int i = 0; i < 4; i++)
        for(int j = 0; j < 2; j++){
            if(charge[i][j]/max_in >= charge_thresh){
=======
    uint8_t tot = 0, maximum = 8; //max can't be a variable name
    for(uint8_t i = 0; i < 4; i++)
        for(uint8_t j = 0; j < 2; j++){
            if(charge[i][j]/1024.f*max_in >= charge_thresh){
>>>>>>> 516c596aa5a4946a59d12a08f62fe5be8a1f8fb1
                tot++;
                digitalWrite(LED_BUILTIN, HIGH);
                delay(100);
                digitalWrite(LED_BUILTIN, LOW);
                delay(400);
            }else if(charge[i][j] < dc_thresh)//dont count disconnected
                maximum--;
        }
    //solid if all done
    if(tot >= maximum)
        digitalWrite(LED_BUILTIN, HIGH);
    else
        digitalWrite(LED_BUILTIN, LOW);
}

 void dispVoltages(){    
    u8g2.clearBuffer();
    u8g2.setDrawColor(1);

    u8g2.drawFrame(0, 16, 64, 48);
    u8g2.drawFrame(64, 16, 64, 48);
    
    uint8_t maxi = 0;
    uint8_t maxj = 0;
    for(uint8_t i = 0; i < 4; i++){
        for(uint8_t j = 0; j < 2; j++){
            //charge[i][j] = random(0, 1024);
            if(charge[i][j] > charge[maxi][maxj]){
                maxi = i;
                maxj = j;
            }

            u8g2.setCursor(i*32+6, j*24+20);
            u8g2.print((char)(65+i*2+j));
            u8g2.print(":");
            u8g2.setCursor(i*32+6, j*24+28);
            if(charge[i][j] < dc_thresh) {
                u8g2.print("NONE");
            } else {
                u8g2.print(charge[i][j]/1024.f*max_in, 1);
                u8g2.print("V");
            }
        }
    }

    u8g2.setCursor(0, 0);
    u8g2.print("Most Charged Battery: ");
    u8g2.print((char)(65+maxi*2+maxj));
    u8g2.setCursor(0, 8);
    u8g2.print("Refreshed ");
    u8g2.print(timesincerefresh);
    u8g2.print(" sec ago");     

    if(maxi%2 == 0)
      u8g2.drawFrame(maxi*32, maxj*24+16, 34, 24);
    else
      u8g2.drawFrame(maxi*32, maxj*24+16, 32, 24);
    
    u8g2.sendBuffer();
}

